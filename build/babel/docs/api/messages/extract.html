

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Low-Level Extraction Interface &mdash; orbkit 0.2.2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../../../_static/orbkit.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="orbkit 0.2.2 documentation" href="../../../../../index.html"/> 

  
  <script src="../../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../../index.html" class="icon icon-home"> orbkit
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../general.html">General Aspects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../quick.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../gridbased/index.html">Grid-Based Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nongridbased/index.html">Non Grid-Based Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../adtutorials/index.html">Advanced Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../refs/index.html">Orbkit References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../licence.html">Licence Note</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../impressum.html">Impressum - Legal Notice</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../../index.html">orbkit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
      
    <li>Low-Level Extraction Interface</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../../../_sources/build/babel/docs/api/messages/extract.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-babel.messages.extract">
<span id="low-level-extraction-interface"></span><h1>Low-Level Extraction Interface<a class="headerlink" href="#module-babel.messages.extract" title="Permalink to this headline">¶</a></h1>
<p>The low level extraction interface can be used to extract from directories
or files directly.  Normally this is not needed as the command line tools
can do that for you.</p>
<div class="section" id="extraction-functions">
<h2>Extraction Functions<a class="headerlink" href="#extraction-functions" title="Permalink to this headline">¶</a></h2>
<p>The extraction functions are what the command line tools use internally to
extract strings.</p>
<dl class="function">
<dt id="babel.messages.extract.extract_from_dir">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract_from_dir</code><span class="sig-paren">(</span><em>dirname=None, method_map=[('**.py', 'python')], options_map=None, keywords={'pgettext': ((1, 'c'), 2), 'gettext': None, 'ugettext': None, 'N_': None, 'dngettext': (2, 3), 'ungettext': (1, 2), 'dgettext': (2,), '_': None, 'ngettext': (1, 2)}, comment_tags=(), callback=None, strip_comment_tags=False</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract_from_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract messages from any source files found in the given directory.</p>
<p>This function generates tuples of the form <code class="docutils literal"><span class="pre">(filename,</span> <span class="pre">lineno,</span> <span class="pre">message,</span>
<span class="pre">comments,</span> <span class="pre">context)</span></code>.</p>
<p>Which extraction method is used per file is determined by the <cite>method_map</cite>
parameter, which maps extended glob patterns to extraction method names.
For example, the following is the default mapping:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">method_map</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="s1">&#39;**.py&#39;</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>This basically says that files with the filename extension &#8221;.py&#8221; at any
level inside the directory should be processed by the &#8220;python&#8221; extraction
method. Files that don&#8217;t match any of the mapping patterns are ignored. See
the documentation of the <cite>pathmatch</cite> function for details on the pattern
syntax.</p>
<p>The following extended mapping would also use the &#8220;genshi&#8221; extraction
method on any file in &#8220;templates&#8221; subdirectory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">method_map</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="s1">&#39;**/templates/**.*&#39;</span><span class="p">,</span> <span class="s1">&#39;genshi&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="s1">&#39;**.py&#39;</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>The dictionary provided by the optional <cite>options_map</cite> parameter augments
these mappings. It uses extended glob patterns as keys, and the values are
dictionaries mapping options names to option values (both strings).</p>
<p>The glob patterns of the <cite>options_map</cite> do not necessarily need to be the
same as those used in the method mapping. For example, while all files in
the <code class="docutils literal"><span class="pre">templates</span></code> folders in an application may be Genshi applications, the
options for those files may differ based on extension:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">options_map</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;**/templates/**.txt&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;template_class&#39;</span><span class="p">:</span> <span class="s1">&#39;genshi.template:TextTemplate&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;encoding&#39;</span><span class="p">:</span> <span class="s1">&#39;latin-1&#39;</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span>    <span class="s1">&#39;**/templates/**.html&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;include_attrs&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span>
<span class="gp">... </span>    <span class="p">}</span>
<span class="gp">... </span><span class="p">}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dirname</strong> &#8211; the path to the directory to extract messages from.  If
not given the current working directory is used.</li>
<li><strong>method_map</strong> &#8211; a list of <code class="docutils literal"><span class="pre">(pattern,</span> <span class="pre">method)</span></code> tuples that maps of
extraction method names to extended glob patterns</li>
<li><strong>options_map</strong> &#8211; a dictionary of additional options (optional)</li>
<li><strong>keywords</strong> &#8211; a dictionary mapping keywords (i.e. names of functions
that should be recognized as translation functions) to
tuples that specify which of their arguments contain
localizable strings</li>
<li><strong>comment_tags</strong> &#8211; a list of tags of translator comments to search for
and include in the results</li>
<li><strong>callback</strong> &#8211; a function that is called for every file that message are
extracted from, just before the extraction itself is
performed; the function is passed the filename, the name
of the extraction method and and the options dictionary as
positional arguments, in that order</li>
<li><strong>strip_comment_tags</strong> &#8211; a flag that if set to <cite>True</cite> causes all comment
tags to be removed from the collected comments.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">See:</th><td class="field-body"><p class="first last"><cite>pathmatch</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="babel.messages.extract.extract_from_file">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract_from_file</code><span class="sig-paren">(</span><em>method</em>, <em>filename</em>, <em>keywords={'pgettext': ((1</em>, <em>'c')</em>, <em>2)</em>, <em>'gettext': None</em>, <em>'ugettext': None</em>, <em>'N_': None</em>, <em>'dngettext': (2</em>, <em>3)</em>, <em>'ungettext': (1</em>, <em>2)</em>, <em>'dgettext': (2</em>, <em>)</em>, <em>'_': None</em>, <em>'ngettext': (1</em>, <em>2)}</em>, <em>comment_tags=()</em>, <em>options=None</em>, <em>strip_comment_tags=False</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract messages from a specific file.</p>
<p>This function returns a list of tuples of the form <code class="docutils literal"><span class="pre">(lineno,</span> <span class="pre">funcname,</span>
<span class="pre">message)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; the path to the file to extract messages from</li>
<li><strong>method</strong> &#8211; a string specifying the extraction method (.e.g. &#8220;python&#8221;)</li>
<li><strong>keywords</strong> &#8211; a dictionary mapping keywords (i.e. names of functions
that should be recognized as translation functions) to
tuples that specify which of their arguments contain
localizable strings</li>
<li><strong>comment_tags</strong> &#8211; a list of translator tags to search for and include
in the results</li>
<li><strong>strip_comment_tags</strong> &#8211; a flag that if set to <cite>True</cite> causes all comment
tags to be removed from the collected comments.</li>
<li><strong>options</strong> &#8211; a dictionary of additional options (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="babel.messages.extract.extract">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract</code><span class="sig-paren">(</span><em>method</em>, <em>fileobj</em>, <em>keywords={'pgettext': ((1</em>, <em>'c')</em>, <em>2)</em>, <em>'gettext': None</em>, <em>'ugettext': None</em>, <em>'N_': None</em>, <em>'dngettext': (2</em>, <em>3)</em>, <em>'ungettext': (1</em>, <em>2)</em>, <em>'dgettext': (2</em>, <em>)</em>, <em>'_': None</em>, <em>'ngettext': (1</em>, <em>2)}</em>, <em>comment_tags=()</em>, <em>options=None</em>, <em>strip_comment_tags=False</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract messages from the given file-like object using the specified
extraction method.</p>
<p>This function returns tuples of the form <code class="docutils literal"><span class="pre">(lineno,</span> <span class="pre">message,</span> <span class="pre">comments)</span></code>.</p>
<p>The implementation dispatches the actual extraction to plugins, based on the
value of the <code class="docutils literal"><span class="pre">method</span></code> parameter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">source</span> <span class="o">=</span> <span class="n">b</span><span class="s1">&#39;&#39;&#39;# foo module</span>
<span class="gp">... </span><span class="s1">def run(argv):</span>
<span class="gp">... </span><span class="s1">   print(_(&#39;Hello, world!&#39;))</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">babel._compat</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">extract</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">(</span><span class="n">source</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="go">(3, u&#39;Hello, world!&#39;, [], None)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> &#8211; an extraction method (a callable), or
a string specifying the extraction method (.e.g. &#8220;python&#8221;);
if this is a simple name, the extraction function will be
looked up by entry point; if it is an explicit reference
to a function (of the form <code class="docutils literal"><span class="pre">package.module:funcname</span></code> or
<code class="docutils literal"><span class="pre">package.module.funcname</span></code>), the corresponding function
will be imported and used</li>
<li><strong>fileobj</strong> &#8211; the file-like object the messages should be extracted from</li>
<li><strong>keywords</strong> &#8211; a dictionary mapping keywords (i.e. names of functions
that should be recognized as translation functions) to
tuples that specify which of their arguments contain
localizable strings</li>
<li><strong>comment_tags</strong> &#8211; a list of translator tags to search for and include
in the results</li>
<li><strong>options</strong> &#8211; a dictionary of additional options (optional)</li>
<li><strong>strip_comment_tags</strong> &#8211; a flag that if set to <cite>True</cite> causes all comment
tags to be removed from the collected comments.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> &#8211; if the extraction method is not registered</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="language-parsing">
<h2>Language Parsing<a class="headerlink" href="#language-parsing" title="Permalink to this headline">¶</a></h2>
<p>The language parsing functions are used to extract strings out of source
files.  These are automatically being used by the extraction functions but
sometimes it can be useful to register wrapper functions, then these low
level functions can be invoked.</p>
<p>New functions can be registered through the setuptools entrypoint system.</p>
<dl class="function">
<dt id="babel.messages.extract.extract_python">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract_python</code><span class="sig-paren">(</span><em>fileobj</em>, <em>keywords</em>, <em>comment_tags</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract messages from Python source code.</p>
<p>It returns an iterator yielding tuples in the following form <code class="docutils literal"><span class="pre">(lineno,</span>
<span class="pre">funcname,</span> <span class="pre">message,</span> <span class="pre">comments)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fileobj</strong> &#8211; the seekable, file-like object the messages should be
extracted from</li>
<li><strong>keywords</strong> &#8211; a list of keywords (i.e. function names) that should be
recognized as translation functions</li>
<li><strong>comment_tags</strong> &#8211; a list of translator tags to search for and include
in the results</li>
<li><strong>options</strong> &#8211; a dictionary of additional options (optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">iterator</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="babel.messages.extract.extract_javascript">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract_javascript</code><span class="sig-paren">(</span><em>fileobj</em>, <em>keywords</em>, <em>comment_tags</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract_javascript" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract messages from JavaScript source code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fileobj</strong> &#8211; the seekable, file-like object the messages should be
extracted from</li>
<li><strong>keywords</strong> &#8211; a list of keywords (i.e. function names) that should be
recognized as translation functions</li>
<li><strong>comment_tags</strong> &#8211; a list of translator tags to search for and include
in the results</li>
<li><strong>options</strong> &#8211; a dictionary of additional options (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="babel.messages.extract.extract_nothing">
<code class="descclassname">babel.messages.extract.</code><code class="descname">extract_nothing</code><span class="sig-paren">(</span><em>fileobj</em>, <em>keywords</em>, <em>comment_tags</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#babel.messages.extract.extract_nothing" title="Permalink to this definition">¶</a></dt>
<dd><p>Pseudo extractor that does not actually extract anything, but simply
returns an empty list.</p>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Gunter Hermann, Vincent Pohl, and Axel Schild.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../../',
            VERSION:'0.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>