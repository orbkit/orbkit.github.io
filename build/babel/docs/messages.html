

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Working with Message Catalogs &mdash; orbkit 0.2.2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/orbkit.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="orbkit 0.2.2 documentation" href="../../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> orbkit
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../general.html">General Aspects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gridbased/index.html">Grid-Based Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nongridbased/index.html">Non Grid-Based Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../adtutorials/index.html">Advanced Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../refs/index.html">Orbkit References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../licence.html">Licence Note</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../impressum.html">Impressum - Legal Notice</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">orbkit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>Working with Message Catalogs</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../_sources/build/babel/docs/messages.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="working-with-message-catalogs">
<span id="messages"></span><h1>Working with Message Catalogs<a class="headerlink" href="#working-with-message-catalogs" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">gettext</span></code> translation system enables you to mark any strings used in your
application as subject to localization, by wrapping them in functions such as
<code class="docutils literal"><span class="pre">gettext(str)</span></code> and <code class="docutils literal"><span class="pre">ngettext(singular,</span> <span class="pre">plural,</span> <span class="pre">num)</span></code>. For brevity, the
<code class="docutils literal"><span class="pre">gettext</span></code> function is often aliased to <code class="docutils literal"><span class="pre">_(str)</span></code>, so you can write:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>instead of just:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">print</span> <span class="s2">&quot;Hello&quot;</span>
</pre></div>
</div>
<p>to make the string &#8220;Hello&#8221; localizable.</p>
<p>Message catalogs are collections of translations for such localizable messages
used in an application. They are commonly stored in PO (Portable Object) and MO
(Machine Object) files, the formats of which are defined by the GNU <a class="reference external" href="http://www.gnu.org/software/gettext/">gettext</a>
tools and the GNU <a class="reference external" href="http://sourceforge.net/projects/translation">translation project</a>.</p>
<blockquote>
<div></div></blockquote>
<p>The general procedure for building message catalogs looks something like this:</p>
<blockquote>
<div><ul class="simple">
<li>use a tool (such as <code class="docutils literal"><span class="pre">xgettext</span></code>) to extract localizable strings from the
code base and write them to a POT (PO Template) file.</li>
<li>make a copy of the POT file for a specific locale (for example, &#8220;en_US&#8221;)
and start translating the messages</li>
<li>use a tool such as <code class="docutils literal"><span class="pre">msgfmt</span></code> to compile the locale PO file into an binary
MO file</li>
<li>later, when code changes make it necessary to update the translations, you
regenerate the POT file and merge the changes into the various
locale-specific PO files, for example using <code class="docutils literal"><span class="pre">msgmerge</span></code></li>
</ul>
</div></blockquote>
<p>Python provides the <code class="xref py py-mod docutils literal"><span class="pre">gettext</span></code> module as part of the standard library,
which enables applications to work with appropriately generated MO files.</p>
<p>As <code class="docutils literal"><span class="pre">gettext</span></code> provides a solid and well supported foundation for translating
application messages, Babel does not reinvent the wheel, but rather reuses this
infrastructure, and makes it easier to build message catalogs for Python
applications.</p>
</div>
<div class="section" id="message-extraction">
<h2>Message Extraction<a class="headerlink" href="#message-extraction" title="Permalink to this headline">¶</a></h2>
<p>Babel provides functionality similar to that of the <code class="docutils literal"><span class="pre">xgettext</span></code> program,
except that only extraction from Python source files is built-in, while support
for other file formats can be added using a simple extension mechanism.</p>
<p>Unlike <code class="docutils literal"><span class="pre">xgettext</span></code>, which is usually invoked once for every file, the routines
for message extraction in Babel operate on directories. While the per-file
approach of <code class="docutils literal"><span class="pre">xgettext</span></code> works nicely with projects using a <code class="docutils literal"><span class="pre">Makefile</span></code>,
Python projects rarely use <code class="docutils literal"><span class="pre">make</span></code>, and thus a different mechanism is needed
for extracting messages from the heterogeneous collection of source files that
many Python projects are composed of.</p>
<p>When message extraction is based on directories instead of individual files,
there needs to be a way to configure which files should be treated in which
manner. For example, while many projects may contain <code class="docutils literal"><span class="pre">.html</span></code> files, some of
those files may be static HTML files that don&#8217;t contain localizable message,
while others may be <a class="reference external" href="http://jinja.pocoo.org/">Jinja2</a> templates, and still others may contain <a class="reference external" href="http://genshi.edgewall.org/">Genshi</a>
markup templates. Some projects may even mix HTML files for different templates
languages (for whatever reason). Therefore the way in which messages are
extracted from source files can not only depend on the file extension, but
needs to be controllable in a precise manner.</p>
<p>Babel accepts a configuration file to specify this mapping of files to
extraction methods, which is described below.</p>
<div class="section" id="front-ends">
<span id="frontends"></span><h3>Front-Ends<a class="headerlink" href="#front-ends" title="Permalink to this headline">¶</a></h3>
<p>Babel provides two different front-ends to access its functionality for working
with message catalogs:</p>
<blockquote>
<div><ul class="simple">
<li>A <a class="reference internal" href="cmdline.html#cmdline"><span class="std std-ref">Command-Line Interface</span></a>, and</li>
<li><a class="reference internal" href="setup.html#setup-integration"><span class="std std-ref">Distutils/Setuptools Integration</span></a></li>
</ul>
</div></blockquote>
<p>Which one you choose depends on the nature of your project. For most modern
Python projects, the distutils/setuptools integration is probably more
convenient.</p>
</div>
<div class="section" id="extraction-method-mapping-and-configuration">
<span id="mapping"></span><h3>Extraction Method Mapping and Configuration<a class="headerlink" href="#extraction-method-mapping-and-configuration" title="Permalink to this headline">¶</a></h3>
<p>The mapping of extraction methods to files in Babel is done via a configuration
file. This file maps extended glob patterns to the names of the extraction
methods, and can also set various options for each pattern (which options are
available depends on the specific extraction method).</p>
<p>For example, the following configuration adds extraction of messages from both
Genshi markup templates and text templates:</p>
<div class="highlight-ini"><div class="highlight"><pre><span></span><span class="c1"># Extraction from Python source files</span>

<span class="k">[python: **.py]</span>

<span class="c1"># Extraction from Genshi HTML and text templates</span>

<span class="k">[genshi: **/templates/**.html]</span>
<span class="na">ignore_tags</span> <span class="o">=</span> <span class="s">script,style</span>
<span class="na">include_attrs</span> <span class="o">=</span> <span class="s">alt title summary</span>

<span class="k">[genshi: **/templates/**.txt]</span>
<span class="na">template_class</span> <span class="o">=</span> <span class="s">genshi.template:TextTemplate</span>
<span class="na">encoding</span> <span class="o">=</span> <span class="s">ISO-8819-15</span>

<span class="c1"># Extraction from JavaScript files</span>

<span class="k">[javascript: **.js]</span>
<span class="na">extract_messages</span> <span class="o">=</span> <span class="s">$._, jQuery._</span>
</pre></div>
</div>
<p>The configuration file syntax is based on the format commonly found in <code class="docutils literal"><span class="pre">.INI</span></code>
files on Windows systems, and as supported by the <code class="docutils literal"><span class="pre">ConfigParser</span></code> module in
the Python standard library. Section names (the strings enclosed in square
brackets) specify both the name of the extraction method, and the extended glob
pattern to specify the files that this extraction method should be used for,
separated by a colon. The options in the sections are passed to the extraction
method. Which options are available is specific to the extraction method used.</p>
<p>The extended glob patterns used in this configuration are similar to the glob
patterns provided by most shells. A single asterisk (<code class="docutils literal"><span class="pre">*</span></code>) is a wildcard for
any number of characters (except for the pathname component separator &#8220;/&#8221;),
while a question mark (<code class="docutils literal"><span class="pre">?</span></code>) only matches a single character. In addition,
two subsequent asterisk characters (<code class="docutils literal"><span class="pre">**</span></code>) can be used to make the wildcard
match any directory level, so the pattern <code class="docutils literal"><span class="pre">**.txt</span></code> matches any file with the
extension <code class="docutils literal"><span class="pre">.txt</span></code> in any directory.</p>
<p>Lines that start with a <code class="docutils literal"><span class="pre">#</span></code> or <code class="docutils literal"><span class="pre">;</span></code> character are ignored and can be used
for comments. Empty lines are ignored, too.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if you&#8217;re performing message extraction using the command Babel
provides for integration into <code class="docutils literal"><span class="pre">setup.py</span></code> scripts, you can also
provide this configuration in a different way, namely as a keyword
argument to the <code class="docutils literal"><span class="pre">setup()</span></code> function. See
<a class="reference internal" href="setup.html#setup-integration"><span class="std std-ref">Distutils/Setuptools Integration</span></a> for more information.</p>
</div>
<div class="section" id="default-extraction-methods">
<h4>Default Extraction Methods<a class="headerlink" href="#default-extraction-methods" title="Permalink to this headline">¶</a></h4>
<p>Babel comes with a few builtin extractors: <code class="docutils literal"><span class="pre">python</span></code> (which extracts
messages from Python source files), <code class="docutils literal"><span class="pre">javascript</span></code>, and <code class="docutils literal"><span class="pre">ignore</span></code> (which
extracts nothing).</p>
<p>The <code class="docutils literal"><span class="pre">python</span></code> extractor is by default mapped to the glob pattern <code class="docutils literal"><span class="pre">**.py</span></code>,
meaning it&#8217;ll be applied to all files with the <code class="docutils literal"><span class="pre">.py</span></code> extension in any
directory. If you specify your own mapping configuration, this default mapping
is discarded, so you need to explicitly add it to your mapping (as shown in the
example above.)</p>
</div>
<div class="section" id="referencing-extraction-methods">
<span id="id1"></span><h4>Referencing Extraction Methods<a class="headerlink" href="#referencing-extraction-methods" title="Permalink to this headline">¶</a></h4>
<p>To be able to use short extraction method names such as âgenshiâ, you need to
have <a class="reference external" href="http://peak.telecommunity.com/DevCenter/PkgResources">pkg_resources</a> installed, and the package implementing that extraction
method needs to have been installed with its meta data (the <a class="reference external" href="http://peak.telecommunity.com/DevCenter/PythonEggs">egg-info</a>).</p>
<p>If this is not possible for some reason, you need to map the short names to
fully qualified function names in an extract section in the mapping
configuration. For example:</p>
<div class="highlight-ini"><div class="highlight"><pre><span></span><span class="c1"># Some custom extraction method</span>

<span class="k">[extractors]</span>
<span class="na">custom</span> <span class="o">=</span> <span class="s">mypackage.module:extract_custom</span>

<span class="k">[custom: **.ctm]</span>
<span class="na">some_option</span> <span class="o">=</span> <span class="s">foo</span>
</pre></div>
</div>
<p>Note that the builtin extraction methods <code class="docutils literal"><span class="pre">python</span></code> and <code class="docutils literal"><span class="pre">ignore</span></code> are available
by default, even if <a class="reference external" href="http://peak.telecommunity.com/DevCenter/PkgResources">pkg_resources</a> is not installed. You should never need to
explicitly define them in the <code class="docutils literal"><span class="pre">[extractors]</span></code> section.</p>
</div>
</div>
<div class="section" id="writing-extraction-methods">
<h3>Writing Extraction Methods<a class="headerlink" href="#writing-extraction-methods" title="Permalink to this headline">¶</a></h3>
<p>Adding new methods for extracting localizable methods is easy. First, you&#8217;ll
need to implement a function that complies with the following interface:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_xxx</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">comment_tags</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract messages from XXX files.</span>

<span class="sd">    :param fileobj: the file-like object the messages should be extracted</span>
<span class="sd">                    from</span>
<span class="sd">    :param keywords: a list of keywords (i.e. function names) that should</span>
<span class="sd">                     be recognized as translation functions</span>
<span class="sd">    :param comment_tags: a list of translator tags to search for and</span>
<span class="sd">                         include in the results</span>
<span class="sd">    :param options: a dictionary of additional options (optional)</span>
<span class="sd">    :return: an iterator over ``(lineno, funcname, message, comments)``</span>
<span class="sd">             tuples</span>
<span class="sd">    :rtype: ``iterator``</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any strings in the tuples produced by this function must be either
<code class="docutils literal"><span class="pre">unicode</span></code> objects, or <code class="docutils literal"><span class="pre">str</span></code> objects using plain ASCII characters.
That means that if sources contain strings using other encodings, it
is the job of the extractor implementation to do the decoding to
<code class="docutils literal"><span class="pre">unicode</span></code> objects.</p>
</div>
<p>Next, you should register that function as an entry point. This requires your
<code class="docutils literal"><span class="pre">setup.py</span></code> script to use <a class="reference external" href="http://peak.telecommunity.com/DevCenter/setuptools">setuptools</a>, and your package to be installed with
the necessary metadata. If that&#8217;s taken care of, add something like the
following to your <code class="docutils literal"><span class="pre">setup.py</span></code> script:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="o">...</span>

    <span class="n">entry_points</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    [babel.extractors]</span>
<span class="s2">    xxx = your.package:extract_xxx</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
</pre></div>
</div>
<p>That is, add your extraction method to the entry point group
<code class="docutils literal"><span class="pre">babel.extractors</span></code>, where the name of the entry point is the name that people
will use to reference the extraction method, and the value being the module and
the name of the function (separated by a colon) implementing the actual
extraction.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As shown in <a class="reference internal" href="#referencing-extraction-methods">Referencing Extraction Methods</a>, declaring an entry
point is not  strictly required, as users can still reference the
extraction  function directly. But whenever possible, the entry point
should be  declared to make configuration more convenient.</p>
</div>
</div>
<div class="section" id="translator-comments">
<h3>Translator Comments<a class="headerlink" href="#translator-comments" title="Permalink to this headline">¶</a></h3>
<p>First of all what are comments tags. Comments tags are excerpts of text to
search for in comments, only comments, right before the <a class="reference external" href="http://docs.python.org/lib/module-gettext.html">python gettext</a>
calls, as shown on the following example:</p>
<blockquote>
<div></div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># NOTE: This is a comment about `Foo Bar`</span>
<span class="n">_</span><span class="p">(</span><span class="s1">&#39;Foo Bar&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The comments tag for the above example would be <code class="docutils literal"><span class="pre">NOTE:</span></code>, and the translator
comment for that tag would be <code class="docutils literal"><span class="pre">This</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">comment</span> <span class="pre">about</span> <span class="pre">`Foo</span> <span class="pre">Bar`</span></code>.</p>
<p>The resulting output in the catalog template would be something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#. This is a comment about `Foo Bar`</span>
<span class="c1">#: main.py:2</span>
<span class="n">msgid</span> <span class="s2">&quot;Foo Bar&quot;</span>
<span class="n">msgstr</span> <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>Now, you might ask, why would I need that?</p>
<p>Consider this simple case; you have a menu item called âmanualâ. You know what
it means, but when the translator sees this they will wonder did you mean:</p>
<ol class="arabic simple">
<li>a document or help manual, or</li>
<li>a manual process?</li>
</ol>
<p>This is the simplest case where a translation comment such as
âThe installation manualâ helps to clarify the situation and makes a translator
more productive.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whether translator comments can be extracted depends on the extraction
method in use. The Python extractor provided by Babel does implement
this feature, but others may not.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Gunter Hermann, Vincent Pohl, and Axel Schild.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>